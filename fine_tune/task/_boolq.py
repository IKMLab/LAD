r"""BoolQ dataset.

Usage:
    import torch.utils.data.Dataloader
    import fine_tune

    dataset = fine_tune.task.BoolQ('train')
    dataset = fine_tune.task.BoolQ('val')
    dataset = fine_tune.task.BoolQ('test')
    dataset = fine_tune.task.BoolQ(...)

    dataset.update_logits(...)
    dataset.save_for_distill()

    assert fine_tune.task.get_num_label(fine_tune.task.BoolQ) == 2

    assert fine_tune.task.label_encoder(
        fine_tune.task.BoolQ,
        fine_tune.task.BoolQ.allow_labels[0]
    ) == 0

    assert fine_tune.task.label_decoder(
        fine_tune.task.BoolQ,
        0
    ) == fine_tune.task.BoolQ.allow_labels[0]

    data_loader = torch.utils.data.Dataloader(
        dataset,
        collate_fn=BoolQ.create_collate_fn(...)
    )
"""

# built-in modules

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

import json
import logging
import os

from typing import List

# 3rd party modules

from tqdm import tqdm

# my own modules

import fine_tune.path

from fine_tune.task._dataset import (
    Dataset,
    Label,
    Sample,
    get_num_class,
    label_encoder,
)

# Get logger.

logger = logging.getLogger('fine_tune.task')

# Define BoolQ dataset.


class BoolQ(Dataset):
    r"""BoolQ dataset and its utilities.

    Args:
        dataset:
            Name of BoolQ dataset file to be loaded. When `dataset` is the name
            of some previous experiment, it must be BoolQ logits dataset
            generated by the model of that experiment.

    Attributes:
        allow_dataset:
            Allowed BoolQ dataset. See BoolQ paper for more details.
        allow_labels:
            Allowed BoolQ labels. See BoolQ paper for labeling details.
        dataset:
            A list of BoolQ samples.
        task_path:
            Path of BoolQ dataset.
    """
    allow_dataset: List[str] = [
        'train',
        'val',
        'test'
    ]

    allow_labels: List[Label] = [
        False,
        True,
    ]

    task_path: str = os.path.join(
        fine_tune.path.FINE_TUNE_DATA,
        'BoolQ'
    )

    @staticmethod
    def load(dataset: str) -> List[Sample]:
        r""" Load BoolQ dataset into memory.

        This is a heavy IO method and might required lots of memory since
        dataset might be huge. BoolQ dataset must be download previously. See
        BoolQ document in 'project_root/doc/fine_tune_boolq.md' for downloading
        details.

        Args:
            dataset:
                Name of the BoolQ dataset to be loaded.

        Raises:
            FileNotFoundError:
                When BoolQ files does not exist.

        Returns:
            A list of BoolQ samples.
        """
        try:
            dataset_path = os.path.join(
                BoolQ.task_path,
                f'{dataset}.jsonl'
            )
            with open(dataset_path, 'r') as jsonl_file:
                jsonlines = jsonl_file.readlines()
        except FileNotFoundError:
            raise FileNotFoundError(
                f'BoolQ dataset file {dataset} does not exist.\n' +
                'You must downloaded previously and put it in the path:\n' +
                f'{dataset_path}\n' +
                "See '" +
                os.path.join(fine_tune.path.DOC, 'fine_tune_boolq.md') +
                "' for downloading details."
            )

        samples = []
        for line in tqdm(jsonlines, desc=f'Loading BoolQ {dataset}'):
            # Skip empty line.
            if line == '':
                continue

            sample = json.loads(line)

            # Test set does not have label field. So we initialize it with
            # meaningless value.
            if 'label' not in sample:
                sample['label'] = False

            # Format into `transformer.PreTrainedTokenizer` format. BoolQ
            # labels will be encoded with `label_encoder(BoolQ, label)`.
            # `logits` will be initialized with 2 zeros.
            samples.append(
                Sample({
                    'text': sample['passage'],
                    'text_pair': sample['question'],
                    'label': label_encoder(BoolQ, sample['label']),
                    'logits': [0.0] * get_num_class(BoolQ)
                })
            )

        logger.info('Number of origin samples: %d', len(jsonlines))
        logger.info('Number of skiped samples: %d', 0)
        logger.info('Number of result samples: %d', len(samples))

        return samples
